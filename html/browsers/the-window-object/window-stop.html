<!doctype html>
<meta charset="utf-8">
<title>window.stop()</title>
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<iframe id="navigate-cancel"></iframe>
<iframe id="navigate-allow"></iframe>
<iframe id="parse"></iframe>
<iframe id="load"></iframe>
<script>
/**
 * TODO: tests for
 *
 * - [ ] Abort the active documents of every child browsing context. If this
 *       results in any of those Document objects having their salvageable
 *       state set to false, then set document's salvageable state to false
 *       also.
 * - [ ] Cancel any instances of the fetch algorithm in the context of
 *       document, discarding any tasks queued for them, and discarding any
 *       further data received from the network for them. If this resulted in
 *       any instances of the fetch algorithm being canceled or any queued
 *       tasks or any network data getting discarded, then set document's
 *       salvageable state to false.
 * - [x] If document has an active parser, then abort that parser and set
 *       document's salvageable state to false.
 */

function poll(t, iframe, done) {
  t.step_timeout(function() {
    if (iframe.contentWindow.name) {
      done();
    } else {
      poll(t, iframe, done);
    }
  }, 100);
}

async_test(function(t) {
  var iframe = document.getElementById('navigate-cancel');
  iframe.src = 'support/window-stop-navigate-cancel.html';

  poll(t, iframe, t.step_func(function() {
    assert_equals(iframe.contentWindow.name, 'success');
    t.done();
  }));
}, 'aborts navigation');

async_test(function(t) {
  var iframe = document.getElementById('navigate-allow');
  iframe.src = 'support/window-stop-navigate-allow.html';

  poll(t, iframe, t.step_func(function() {
    assert_equals(iframe.contentWindow.name, 'loaded destination');
    t.done();
  }));
}, 'allows navigation');


async_test(function(t) {
  var iframe = document.getElementById('load');
  iframe.src = 'support/window-stop-load.html';

  poll(t, iframe, t.step_func(function() {
    assert_equals(iframe.contentWindow.name, 'success');
    t.done();
  }));
}, 'prevents the `load` event');

/**
 * > The stop() method on Window objects should, if there is an existing
 * > attempt to navigate the browsing context and that attempt is not currently
 * > running the unload a document algorithm, cancel that navigation; [...]
 *
 * Evaluation of `javascript:` URLs precedes document unloading [1], so the
 * navigation should be cancelled.
 *
 * [1] https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigate
 */
async_test(function(t) {
  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);

  window.a = {
    firstNavigation: t.step_func(function() {
      assert_unreached('Navigation was not cancelled.');
    }),
    secondNavigation: t.step_func(function() {
      t.done();
    })
  };
  iframe.contentWindow.location = 'javascript:' + [
    'window.stop();',
    'window.location = "javascript: parent.a.secondNavigation();";',
    '"<script>parent.a.firstNavigation();<' + '/script>"'
  ].join('');
}, 'synchronously cancels navigation that is not unloading');
</script>
